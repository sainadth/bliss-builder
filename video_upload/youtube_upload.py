import os
import sys
import argparse
import json
import dotenv
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
import pickle
from pathlib import Path

dotenv.load_dotenv()

SCOPES = ['https://www.googleapis.com/auth/youtube.upload']

# Get script directory for relative paths
SCRIPT_DIR = Path(__file__).resolve().parent

def get_authenticated_service():
    """Authenticate and return YouTube service."""
    credentials = None
    
    # Use paths relative to script directory
    token_file = SCRIPT_DIR / 'token.pickle'
    credentials_file = SCRIPT_DIR / 'youtube_credentials.json'
    
    if token_file.exists():
        with open(token_file, 'rb') as token:
            credentials = pickle.load(token)
    
    if not credentials or not credentials.valid:
        if credentials and credentials.expired and credentials.refresh_token:
            credentials.refresh(Request())
        else:
            if not credentials_file.exists():
                print(f"ERROR: YouTube credentials not found at: {credentials_file}")
                print("Please ensure youtube_credentials.json is in the video_upload folder")
                sys.exit(1)
            
            flow = InstalledAppFlow.from_client_secrets_file(
                str(credentials_file), SCOPES)
            
            # Note for unverified app
            print("Note: App not verified by Google yet.")
            print("Click 'Advanced' then 'Go to Bliss Builder Desktop (unsafe)' to proceed.")
            
            credentials = flow.run_local_server(port=0)
        
        with open(token_file, 'wb') as token:
            pickle.dump(credentials, token)
    
    return build('youtube', 'v3', credentials=credentials)

def upload_youtube_short(video_path: str, theme: str, narration: str = None, privacy: str = "public"):
    """Upload video as YouTube Short with AI content disclosure."""
    youtube = get_authenticated_service()
    
    # CRITICAL: Verify video is portrait before upload
    try:
        import cv2
        cap = cv2.VideoCapture(video_path)
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        duration_sec = int(cap.get(cv2.CAP_PROP_FRAME_COUNT) / cap.get(cv2.CAP_PROP_FPS))
        cap.release()
        
        print(f"\nPre-upload validation:")
        print(f"  Resolution: {width}x{height}")
        print(f"  Duration: {duration_sec}s")
        
        # Shorts requirements
        is_portrait = height > width
        is_short_duration = duration_sec <= 60
        is_correct_ratio = 1.5 < (height / width) < 2.0  # Roughly 9:16
        
        if not is_portrait:
            print(f"  ERROR: Video is NOT portrait! ({width}x{height})")
            print(f"  This will NOT appear as a Short!")
            print(f"  Please fix video generation to output 1080x1920")
        
        if not is_short_duration:
            print(f"  ERROR: Video too long for Shorts! ({duration_sec}s > 60s)")
        
        if not is_correct_ratio:
            print(f"  WARNING: Aspect ratio not ideal for Shorts ({height/width:.2f})")
        
        if is_portrait and is_short_duration and is_correct_ratio:
            print(f"  SUCCESS: Video meets YouTube Shorts requirements!")
        
    except Exception as e:
        print(f"Could not validate video: {e}")
    
    # Title MUST include #Shorts (critical for Shorts feed)
    title = f"ASMR Loop: {theme} #Shorts"[:100]
    
    # Description MUST mention it's a Short in first line
    description = (
        f"#Shorts - {theme}\n\n"  # CRITICAL: #Shorts at the very start
        f"AI-GENERATED CONTENT: Created using Google Veo 3 AI\n"
        f"SEAMLESS 8-SECOND LOOP - Perfect for endless relaxation\n\n"
        f"TRANSPARENCY NOTICE:\n"
        f"- Video: Generated by Google Veo 3 AI\n"
        f"- Audio: AI-enhanced ambient sounds\n"
        f"- No real people, places, or events depicted\n"
        f"- Created for relaxation and meditation purposes\n\n"
        f"#Shorts #ASMR #ASMRShorts #AIGenerated #AIArt #SyntheticMedia\n\n"
        f"Best with headphones | Perfect for relaxation\n"
        f"Seamless loop - watch on repeat!\n"
        f"Subscribe for daily AI-generated ASMR Shorts\n\n"
    )
    
    if narration:
        description += f"Video concept: {narration[:150]}...\n\n"
    
    description += (
        "DISCLAIMER: AI-generated content for entertainment and relaxation.\n"
        "No copyright infringement intended. All visuals are original AI creations.\n\n"
        "Tags: AI ASMR, Synthetic Media, Machine Learning, Relaxation"
    )
    
    # Metadata with AI disclosure
    body = {
        "snippet": {
            "title": title,
            "description": description,
            "tags": [
                "Shorts", "ASMR", "ASMR Shorts", "AI Generated", "AI Art",
                "AI Video", "Synthetic Media", "AI ASMR", "Looping video",
                "Relaxing", "Meditation", "8 second loop", "Google Veo"
            ],
            "categoryId": "22"
        },
        "status": {
            "privacyStatus": privacy,  # DEFAULT: "public" (safe with AI disclosure)
            "selfDeclaredMadeForKids": False,
            "madeForKids": False
        }
    }
    
    print(f"Uploading AI-generated YouTube Short: {title}")
    print(f"  Privacy: {privacy}")
    print(f"  #Shorts in title: YES")
    print(f"  #Shorts in description: YES")
    print(f"  [OK] AI disclosure in description")
    
    # Upload with progress tracking
    media = MediaFileUpload(
        video_path,
        mimetype="video/mp4",
        resumable=True,
        chunksize=1024*1024
    )
    
    request = youtube.videos().insert(
        part="snippet,status",
        body=body,
        media_body=media
    )
    
    response = None
    while response is None:
        try:
            status, response = request.next_chunk()
            if status:
                print(f"Upload progress: {int(status.progress() * 100)}%", flush=True)
        except Exception as e:
            print(f"Upload error: {e}", flush=True)
            raise
    
    video_id = response['id']
    video_url = f"https://www.youtube.com/shorts/{video_id}"
    
    print(f"\nSUCCESS: AI-generated Short published!")
    print(f"Video ID: {video_id}")
    print(f"URL: {video_url}")
    print(f"\nCompliance checklist:")
    print(f"  [OK] AI disclosure in description")
    print(f"  [OK] No misleading claims")
    print(f"  [OK] Clear synthetic media labeling")
    
    return {
        "video_id": video_id,
        "video_url": video_url,
        "title": title,
        "status": "published",
        "privacy": privacy,
        "ai_disclosed": True
    }

def main():
    parser = argparse.ArgumentParser(description="Upload AI-generated video to YouTube as Short")
    parser.add_argument("--video", required=True, help="Path to video file")
    parser.add_argument("--theme-file", required=True, help="Path to theme.txt")
    parser.add_argument("--narration-file", help="Path to narration.txt (optional)")
    parser.add_argument("--output-result", help="Path to save upload result JSON")
    parser.add_argument("--privacy", default="public", choices=["public", "unlisted", "private"],
                       help="Privacy status (default: public)")
    args = parser.parse_args()
    
    # Validate video file
    if not os.path.exists(args.video):
        print(f"ERROR: Video file not found: {args.video}")
        sys.exit(1)
    
    # Load theme
    if not os.path.exists(args.theme_file):
        print(f"ERROR: Theme file not found: {args.theme_file}")
        sys.exit(1)
    
    with open(args.theme_file, 'r', encoding='utf-8') as f:
        theme = f.read().strip()
    
    # Load narration (optional)
    narration = None
    if args.narration_file and os.path.exists(args.narration_file):
        with open(args.narration_file, 'r', encoding='utf-8') as f:
            narration = f.read().strip()
    
    # Upload
    result = upload_youtube_short(args.video, theme, narration, args.privacy)
    
    # Save result
    if args.output_result:
        os.makedirs(os.path.dirname(os.path.abspath(args.output_result)), exist_ok=True)
        with open(args.output_result, 'w', encoding='utf-8') as f:
            json.dump(result, f, indent=2)
        print(f"\nUpload result saved to: {args.output_result}")

if __name__ == "__main__":
    main()
